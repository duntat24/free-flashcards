import AddFlashcardButton from '../../AddFlashcardButton.js';
import NewFlashcard from './NewFlashcard.js';
import SaveNewSetButton from './SaveNewSetButton.js';
import { useState } from 'react';
import axios from 'axios';

/*
    TODO: The props likely need a way to trigger a hook to make another fetch to the API - otherwise our additions won't be reflected on the home page
*/
export default function CreateFlashcardSet() {
    const [cards, updateCards] = useState([]);
    // we use the ID for displaying, deleting, & updating the cards - the card's ID on the backend is generated by the server
    const [nextCardId, updateNextCardId] = useState(0);
    const [setTitle, updateSetTitle] = useState("");

    function addCard() { // this adds a blank card to the newly created set
        updateCards([...cards, {id: nextCardId, prompt: "", response: "", fileJSON: {file: null, isPrompt: null}, userResponseType: "text"}]);
        updateNextCardId(nextCardId + 1);
    }
    function removeCard(removedId) {
        updateCards(cards.filter(card => card.id !== removedId)); // finding and removing the card with the specified id
    }
    function updateCard(newPrompt, newResponse, cardId, newFileJSON, newUserResponseType) { // this is used to update cards when the user edits a prompt or response
        updateCards(cards.map(card => 
            card.id === cardId ? {id: cardId, prompt: newPrompt, response: newResponse, 
                                  fileJSON: newFileJSON, userResponseType: newUserResponseType}: card
        ));
    }
    function saveSet() {
        /*
            Need to make an API call here
        */
        // first need to validate that all the cards have a valid state - non-empty prompt and response, indicate whether file is for a prompt or response
        if (!validateCards(cards) || setTitle === "") {
            alert("Please ensure all entered data is valid"); // there should be more graceful error handling than this
            return;
            // 1. don't use alert
            // 2. Clearly indicate which fields are invalid & why
            // (should do this later, for now just get base functionality up)
        }
        const setPostURL = "http://localhost:3001/sets";
        const newSetData = {title: setTitle};
        axios.post(setPostURL, newSetData).then((response) => {
            const newSetId = response.data._id; // we need the id of the newly created set so we can POST our flashcards to it
            
            // executing this logic after the response is received ensures we've received the set ID to post to
            const cardPostURL = "http://localhost:3001/sets/" + newSetId;
            for (let i = 0; i < cards.length; i++) {
                let card = cards[i];
                axios.post(cardPostURL, {prompt: card.prompt, response: card.response, 
                        userResponseType: card.userResponseType}).then((response) => {
                            console.log(response);
                        }).catch((error) => {
                            console.log(error);
                            return; // we need more graceful handling than this, we don't want to partially post a set to the API
                        });
            }
        }).catch((error) => {
            console.log(error);
            return; // we should immediately break out of our attempt to create a set if our request fails
        });
        

        // once all flashcards are validated, we should POST a new study set with the specified title
        // then, we should iterate through each card and initiate an ASYNCHRONOUS request
            // if the request contains a file, we need to then call 

        /* updateCards([]); // clear the existing cards to make it simpler for the user to create another new set
        updateSetTitle(""); // clear the set title to make it easier for the user

        we will add this functionality back when we finish making the API call - don't want to re-enter every time we test
        */ 
    }

    let cardList = cards.map(card => (
        <li key={card.id} className="new-flashcard"> 
            <NewFlashcard
                card={card}
                removeCard={removeCard}
                updateCard={updateCard}
            />
        </li>
    ));
    
    return <div className="new-flashcard-set">
        <AddFlashcardButton 
            addCard={addCard}
        />
        <SaveNewSetButton
            save={saveSet}
        /> <br/>
        <label htmlFor="set-title">Set Title:</label>
        <input type="text" name="set-title" id="set-title" value={setTitle} 
            onChange={(e) => updateSetTitle(e.target.value)}></input>
        <ul className="new-card-list">
            {cardList}
        </ul>
    </div>
}

// this method validates the provided array of cards so they can be stored on the server
function validateCards(cards) {
    if (cards.length === 0) { // sets should initially contain at least 1 card, fewer than that doesn't make sense
        return false;
    }
    for (let i = 0; i < cards.length; i++) {
        const currentCard = cards[i];
        if (currentCard.prompt === "" || currentCard.response === "") { // prompt and response can't be null
            return false;
        }
        if (currentCard.fileJSON.file !== null && currentCard.fileJSON.isPrompt === null) { // user must indicate where a file should be displayed as part of a card 
            return false;
        }
    }
    return true; // all cards are valid if we get here
}